# Domain-Driven Design
## 정의
DDD (Domain-driven design)은 객체지향 소프트웨어 설계 방법론 중 하나로, 소프트웨어 시스템을 구축할 때, 비즈니스 도메인 (domain)에 집중하여 개발하는 방법을 말합니다. 즉, 소프트웨어 시스템의 핵심이 되는 도메인을 정의하고, 이를 기반으로 하여 객체 모델을 구축하고 비즈니스 로직을 구현함으로써, 소프트웨어 시스템을 개발하는 방법입니다.

DDD는 비즈니스 도메인의 개념과 구조를 이해하고, 이를 객체 모델로 표현하며, 이러한 객체 모델을 기반으로 소프트웨어 시스템을 구축합니다. 이를 통해 개발자와 도메인 전문가 간의 의사소통을 원활하게 하고, 비즈니스 로직의 복잡성을 줄이며, 유지보수성과 확장성을 높일 수 있습니다.

## 장단점
### 장점
비즈니스 로직에 집중하여 개발할 수 있으므로, 비즈니스 요구사항을 충족하는 높은 품질의 소프트웨어 시스템을 구축할 수 있습니다.
도메인 전문가와 개발자 간의 의사소통을 원활하게 할 수 있습니다.
객체 모델을 중심으로 소프트웨어 시스템을 구축하기 때문에, 유지보수성과 확장성이 높습니다.
비즈니스 도메인을 잘 이해하고 분석하므로, 비즈니스 도메인의 문제를 더 잘 파악하고 해결할 수 있습니다.

#### 품질속성
- 모듈성: DDD는 모듈화된 아키텍처를 채택하기 때문에, 시스템이 모듈화되고 독립적으로 변경할 수 있습니다.
- 유연성: DDD는 비즈니스 도메인에 중점을 둔 설계 방식이기 때문에, 변화에 유연하게 대처할 수 있습니다.
- 확장성: DDD는 모듈화와 유연성으로 인해, 시스템이 쉽게 확장될 수 있습니다.
- 테스트 용이성: DDD는 비즈니스 로직에 집중하기 때문에, 테스트가 쉽고 효율적입니다.
- 의사소통: DDD는 도메인 전문가와 개발자 간의 의사소통을 원활하게 할 수 있습니다.


### 단점
기존의 소프트웨어 개발 방법과 달리, 초기에 비즈니스 도메인을 충분히 이해하고 분석해야 하므로 초기 개발 비용이 높을 수 있습니다.
객체 모델을 구현하고, 비즈니스 로직을 구현하는 데 필요한 시간이 많이 소요될 수 있습니다.
개발자가 비즈니스 도메인에 대한 전문 지식을 가져야 하므로, 개발자의 역량과 노력이 요구됩니다.
도메인 모델이 복잡해지면, 유지보수가 어려워질 수 있습니다.
#### 품질속성
- 복잡성: DDD는 비즈니스 도메인에 중점을 둔 설계 방식이기 때문에, 설계의 복잡성이 증가할 수 있습니다.
- 초기 비용: DDD는 비즈니스 도메인에 대한 분석과 이해가 필요하기 때문에, 초기 비용이 증가할 수 있습니다.
- 기술 복잡성: DDD는 도메인 모델의 구현과 관련된 기술적인 복잡성이 증가할 수 있습니다.
- 성능: DDD는 모듈화와 유연성이 중요하다는 것 때문에, 성능 문제가 발생할 수 있습니다.


## 프로세스
1. 비즈니스 도메인 이해(Understanding the business domain): DDD는 비즈니스 도메인에 집중하는 설계 방식입니다. 따라서, DDD를 구현하기 전에는 먼저 비즈니스 도메인에 대해 충분한 이해를 해야 합니다. 비즈니스 전문가와 대화를 나누고 도메인 모델을 만들어서 문제를 잘 이해하고 분석합니다.

2. 유비쿼터스 언어 사용(Developing a ubiquitous language): DDD는 유비쿼터스 언어를 사용하여 도메인 전문가와 개발자 간의 의사소통을 원활하게 합니다. 유비쿼터스 언어는 비즈니스 용어와 용어의 의미를 공유하는 공통 언어로, 모든 관련자들은 이 언어를 사용하여 의사소통합니다.

3. Bounded Context 식별(Identifying bounded contexts): Bounded Context는 특정 도메인에서의 언어와 모델의 경계를 의미합니다. 따라서, DDD를 구현하기 위해서는 Bounded Context를 식별하고, 도메인 전문가와 개발자가 이해할 수 있는 모델을 만들어야 합니다.

4. Entity 및 Value Object 정의(Defining entities and value objects): Entity와 Value Object는 DDD에서 중요한 개념입니다. Entity는 유일한 식별자와 상태를 가지며, Value Object는 불변성을 가지며 일정한 상태를 유지합니다. 따라서, DDD를 구현하기 위해서는 Entity와 Value Object를 정의하고, 도메인 모델을 만들어야 합니다.

5. Aggregate 및 Repository 정의(Defining aggregates and repositories): Aggregate는 Entity와 Value Object의 그룹입니다. Repository는 Aggregate를 저장하고, 검색하고, 수정하는 인터페이스를 제공합니다. 따라서, DDD를 구현하기 위해서는 Aggregate와 Repository를 정의하고, 도메인 모델을 만들어야 합니다.

6. 도메인 서비스 정의(Defining domain services): 도메인 서비스는 도메인 모델에서 수행되는 비즈니스 로직입니다. 따라서, DDD를 구현하기 위해서는 도메인 서비스를 정의하고, 도메인 모델을 만들어야 합니다.

7. 인프라 구현(Implementing the infrastructure): 마지막으로, DDD는 도메인 모델을 지원하는 데이터베이스, 웹 서버, 메시지 브로커 등의 기술적 구성 요소를 구현하는 것을 필요로합니다.

다음 링크에서 많은 방법론을 공부할 수 있습니다 : https://github.com/ddd-crew/

#### Bounded Context? 
두 가지 제품 유형, 즉 전자제품과 의류를 판매하는 회사가 있다고 상상해보세요. 이 두 가지 제품 유형은 각기 다른 과정, 다른 언어 및 다른 개념이 필요합니다. 예를 들어, 전자 제품 부서에서는 프로세서, RAM 및 하드 드라이브와 같은 용어를 사용할 수 있고, 의류 부서에서는 사이즈, 색상 및 소재에 대해 이야기할 수 있습니다.

이 예에서, **전자 제품 부서와 의류 부서**를 두 가지 다른 **Bounded Context**로 생각할 수 있습니다. 각 Bounded Context 내에서 언어, 개념 및 프로세스는 해당 부서의 특정 요구 사항에 맞춰져 있으며, 서로 다른 부서 간에는 같지 않을 수 있습니다.

이와 같이 Bounded Context를 사용하여 대규모이고 복잡한 비즈니스 도메인을 더 잘 조직화하고 단순화할 수 있습니다. 이를 통해 개발 팀은 각 Bounded Context의 이해 관계자 요구 사항을 정확하게 대표하고 해당 Context의 특정 요구 사항을 충족시키는 소프트웨어를 개발할 수 있습니다.

#### Entity vs. Value Object

Entity는 고유한 식별자(identity)와 시간에 따른 생명주기(lifecycle)를 가진 객체입니다. 즉, Entity는 속성과 도메인 내 다른 객체와의 관계로 정의된 객체입니다. 예를 들어, 사람은 이름, 나이, 주소와 같은 속성을 가진 Entity입니다. 만약 사람이 새로운 주소로 이사를 가면, 식별자는 변경되지 않지만 주소 속성은 변경됩니다.

반면에 Value Object는 속성(attribute)만으로 정의되며 고유한 식별자(identity)를 갖지 않는 객체입니다. 즉, Value Object는 불변하며, 동일한 속성을 가진 다른 Value Object로 대체될 수 있습니다. 예를 들어, 날짜는 일(day), 월(month), 년(year)과 같은 속성을 가진 Value Object입니다. 두 날짜 객체가 동일한 속성을 가지면, 동일한 시간을 나타냅니다. 따라서 식별자를 추적할 필요가 없습니다.

Entity와 Value Object의 차이점을 설명하는 예시를 들어보겠습니다. 호텔 예약 관리 시스템이 있다고 가정해보겠습니다. 예약은 유일한 식별자(예약 번호)와 생명주기를 가진 Entity입니다. 고객이 예약을 취소하더라도, 예약 객체는 삭제되지 않고 상태 속성이 "취소됨"으로 업데이트됩니다.

이제 상품의 배송비를 계산하는 시스템이 있다고 가정해보겠습니다. 상품의 무게와 크기는 속성(attribute)으로 정의되며, 고유한 식별자를 갖지 않기 때문에 Value Object입니다. 만약 두 상품이 동일한 무게와 크기를 가진다면, 식별자를 추적할 필요 없이 동일하게 처리할 수 있습니다.

## 구조
### 계층 구조
1. Presentation Layer: 사용자 인터페이스와 관련된 코드를 포함합니다. 애플리케이션의 사용자와 상호작용하며, 유스케이스를 구성하는 역할을 합니다.
2. Application Layer: 사용자 인터페이스와 도메인 계층 사이의 중간 계층입니다.애플리케이션의 비즈니스 로직을 구현하며, 도메인 계층에서 제공하는 서비스와 도메인 객체를 사용합니다.
3. Domain Layer: 애플리케이션의 핵심이 되는 도메인 모델을 포함합니다. 도메인 객체와 그 관련 로직을 정의하며, 엔티티와 밸류 객체, 그리고 도메인 서비스를 포함합니다.
4. Infrastructure Layer: 애플리케이션의 인프라스트럭처와 관련된 코드를 포함합니다. 데이터베이스, 메시징 시스템, 웹 서비스 등과 같은 외부 시스템과의 연결을 처리합니다.
5. Test Layer: 테스트 코드를 포함합니다. 단위 테스트, 통합 테스트, 시스템 테스트 등을 수행하며, 품질 보증과 디버깅에 사용됩니다.

### Onion 구조
이 접근 방식에서 애플리케이션은 도메인 레이어가 중심이 되고 인프라스트럭처 레이어가 바깥쪽에 위치한 동심원으로 나뉘어집니다.


## 폴더 구조

굳이 이렇게 따라야 할 필요는 없지만 보통의 폴더구조는 이렇습니다.

```markdown
├── application
│   ├── services
│   └── use_cases
├── domain
│   ├── entities
│   ├── events
│   ├── repositories
│   ├── services
│   └── value_objects
├── infrastructure
│   ├── repositories
│   └── services
├── interfaces
│   ├── controllers
│   ├── gateways
│   ├── presenters
│   └── views
└── tests
    ├── application
    ├── domain
    ├── infrastructure
    └── interfaces

```
